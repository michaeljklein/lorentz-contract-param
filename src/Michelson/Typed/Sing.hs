{-# OPTIONS_GHC -fno-warn-orphans #-}

-- | Module, providing singleton boilerplate for
-- 'T' and 'CT' data types.
--
-- Some functions from Data.Singletons are provided alternative version here.
-- Some instances which are usually generated with TH are manually implemented
-- as they require some specific constraints, namely 'Typeable' and/or
-- 'Converge', not provided in instances generated by TH.

module Michelson.Typed.Sing
  (
    Sing (..)
  , withSomeSingT
  , withSomeSingCT
  , fromSingT
  , fromSingCT
  ) where

import Data.Kind (Type)
import Data.Singletons (Sing(..), SingI(..))

import Michelson.Typed.T
  (CAddress, CBool, CBytes, CInt, CKeyHash, CMutez, CNat, CString, CT(..), CTimestamp, T(..),
  TBigMap, TContract, TKey, TLambda, TList, TMap, TOperation, TOption, TOr, TPair, TSet,
  TSignature, TUnit, Tc)

-- | Instance of data family 'Sing' for 'CT'.
data instance Sing :: CT -> Type where
  SCInt       :: Sing CInt
  SCNat       :: Sing CNat
  SCString    :: Sing CString
  SCBytes     :: Sing CBytes
  SCMutez     :: Sing CMutez
  SCBool      :: Sing CBool
  SCKeyHash   :: Sing CKeyHash
  SCTimestamp :: Sing CTimestamp
  SCAddress   :: Sing CAddress

class (SingI a, Typeable a) => SingT a
instance (SingI a, Typeable a) => SingT a

-- | Instance of data family 'Sing' for 'T'.
-- Custom instance is implemented in order to inject 'Typeable'
-- constraint for some of constructors.
data instance Sing :: T -> Type where
  STc          :: SingT a => Sing a -> Sing (Tc a)
  STKey        :: Sing  TKey
  STUnit       :: Sing  TUnit
  STSignature  :: Sing  TSignature
  STOption     :: SingT a => Sing a -> Sing (TOption a)
  STList       :: SingT a => Sing a -> Sing (TList a )
  STSet        :: SingT a => Sing a -> Sing (TSet a )
  STOperation  :: Sing TOperation
  STContract   :: SingT a => Sing a -> Sing (TContract a )
  STPair       :: (SingT a, SingT b) => Sing a -> Sing b -> Sing (TPair a b)
  STOr         :: (SingT a, SingT b) => Sing a -> Sing b -> Sing (TOr a b)
  STLambda     :: (SingT a, SingT b) => Sing a -> Sing b -> Sing (TLambda a b)
  STMap        :: (SingT a, SingT b) => Sing a -> Sing b -> Sing (TMap a b)
  STBigMap     :: (SingT a, SingT b) => Sing a -> Sing b -> Sing (TBigMap a b)

---------------------------------------------
-- Singleton-related instances for CT
---------------------------------------------

-- | Version of 'SomeSing' with 'Typeable' constraint,
-- specialized for use with 'CT' kind.
data SomeSingCT where
  SomeSingCT :: forall (a :: CT). SingT a => Sing a -> SomeSingCT

-- | Version of 'withSomeSing' with 'Typeable' constraint
-- provided to processing function.
--
-- Required for not to erase this useful constraint when doing
-- conversion from value of type 'CT' to its singleton representation.
withSomeSingCT :: CT -> (forall (a :: CT). SingT a => Sing a -> r) -> r
withSomeSingCT ct f = (\(SomeSingCT s) -> f s) (toSingCT ct)

fromSingCT :: Sing (a :: CT) -> CT
fromSingCT SCInt       = CInt
fromSingCT SCNat       = CNat
fromSingCT SCString    = CString
fromSingCT SCBytes     = CBytes
fromSingCT SCMutez     = CMutez
fromSingCT SCBool      = CBool
fromSingCT SCKeyHash   = CKeyHash
fromSingCT SCTimestamp = CTimestamp
fromSingCT SCAddress   = CAddress

-- | Version of 'toSing' which creates 'SomeSingCT'.
toSingCT :: CT -> SomeSingCT
toSingCT CInt       = SomeSingCT SCInt
toSingCT CNat       = SomeSingCT SCNat
toSingCT CString    = SomeSingCT SCString
toSingCT CBytes     = SomeSingCT SCBytes
toSingCT CMutez     = SomeSingCT SCMutez
toSingCT CBool      = SomeSingCT SCBool
toSingCT CKeyHash   = SomeSingCT SCKeyHash
toSingCT CTimestamp = SomeSingCT SCTimestamp
toSingCT CAddress   = SomeSingCT SCAddress

instance SingI CInt       where sing = SCInt
instance SingI CNat       where sing = SCNat
instance SingI CString    where sing = SCString
instance SingI CBytes     where sing = SCBytes
instance SingI CMutez     where sing = SCMutez
instance SingI CBool      where sing = SCBool
instance SingI CKeyHash   where sing = SCKeyHash
instance SingI CTimestamp where sing = SCTimestamp
instance SingI CAddress   where sing = SCAddress

---------------------------------------------
-- Singleton-related helpers for T
-------------------------------------------CT
-- | Version of 'SomeSing' with 'Typeable' constraint,
-- specialized for use with 'T' kind.
data SomeSingT where
  SomeSingT :: forall (a :: T). (SingT a) => Sing a -> SomeSingT

-- | Version of 'withSomeSing' with 'Typeable' constraint
-- provided to processing function.
--
-- Required for not to erase these useful constraints when doing
-- conversion from value of type 'T' to its singleton representation.
withSomeSingT :: T -> (forall (a :: T). SingT a => Sing a -> r) -> r
withSomeSingT t f = (\(SomeSingT s) -> f s) (toSingT t)

-- | Version of 'fromSing' specialized for use with
-- @data instance Sing :: T -> Type@ which requires 'Typeable'
-- constraint for some of its constructors
fromSingT :: Sing (a :: T) -> T
fromSingT (STc t)         = Tc (fromSingCT t)
fromSingT STKey           = TKey
fromSingT STUnit          = TUnit
fromSingT STSignature     = TSignature
fromSingT (STOption t)    = TOption (fromSingT t)
fromSingT (STList t)      = TList (fromSingT t)
fromSingT (STSet t)       = TSet (fromSingCT t)
fromSingT STOperation     = TOperation
fromSingT (STContract t)  = TContract (fromSingT t)
fromSingT (STPair a b)    = TPair (fromSingT a) (fromSingT b)
fromSingT (STOr a b)      = TOr (fromSingT a) (fromSingT b)
fromSingT (STLambda a b)  = TLambda (fromSingT a) (fromSingT b)
fromSingT (STMap a b)     = TMap (fromSingCT a) (fromSingT b)
fromSingT (STBigMap a b)  = TBigMap (fromSingCT a) (fromSingT b)

-- | Version of 'toSing' which creates 'SomeSingT'.
toSingT :: T -> SomeSingT
toSingT = \case
 Tc ct       -> withSomeSingCT ct $ \ctSing -> SomeSingT $ STc ctSing
 TKey        -> SomeSingT STKey
 TUnit       -> SomeSingT STUnit
 TSignature  -> SomeSingT STSignature
 TOption t   -> withSomeSingT t $ \tSing -> SomeSingT $ STOption tSing
 TList t     -> withSomeSingT t $ \tSing -> SomeSingT $ STList tSing
 TSet ct     -> withSomeSingCT ct $ \ctSing -> SomeSingT $ STSet ctSing
 TOperation  -> SomeSingT STOperation
 TContract t -> withSomeSingT t $ \tSing -> SomeSingT $ STContract tSing
 TPair l r   -> withSomeSingT l $ \lSing -> withSomeSingT r $ \rSing ->
                SomeSingT $ STPair lSing rSing
 TOr l r     -> withSomeSingT l $ \lSing -> withSomeSingT r $ \rSing ->
                SomeSingT $ STOr lSing rSing
 TLambda l r -> withSomeSingT l $ \lSing -> withSomeSingT r $ \rSing ->
                SomeSingT $ STLambda lSing rSing
 TMap l r    -> withSomeSingCT l $ \lSing -> withSomeSingT r $ \rSing ->
                SomeSingT $ STMap lSing rSing
 TBigMap l r -> withSomeSingCT l $ \lSing -> withSomeSingT r $ \rSing ->
                SomeSingT $ STBigMap lSing rSing

instance SingT t => SingI (Tc (t :: CT))           where sing = STc sing
instance SingI TKey                                where sing = STKey
instance SingI TUnit                               where sing = STUnit
instance SingI TSignature                          where sing = STSignature
instance SingT a => SingI (TOption (a :: T))       where sing = STOption sing
instance SingT a => SingI (TList (a :: T))         where sing = STList sing
instance SingT a => SingI (TSet (a :: CT))         where sing = STSet sing
instance SingI TOperation                          where sing = STOperation
instance SingT a => SingI (TContract (a :: T))     where sing = STContract sing
instance (SingT a, SingT b) => SingI (TPair a b)   where sing = STPair sing sing
instance (SingT a, SingT b) => SingI (TOr a b)     where sing = STOr sing sing
instance (SingT a, SingT b) => SingI (TLambda a b) where sing = STLambda sing sing
instance (SingT a, SingT b) => SingI (TMap a b)    where sing = STMap sing sing
instance (SingT a, SingT b) => SingI (TBigMap a b) where sing = STBigMap sing sing

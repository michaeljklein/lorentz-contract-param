{-# LANGUAGE DeriveAnyClass #-}

-- | An executable for haskell preprocessor which finds
-- all contract declarations in Haskell modules within the directory where
-- preprocessor is called and exports found contracts in a map.
module Main
  ( main
  ) where

import qualified Unsafe

import Data.Default (Default(..))
import qualified Data.Text as T
import Fmt (Builder, build, fmt, indentF, listF', unlinesF, (+|), (|+))
import Language.Haskell.Exts
  (ExportSpec(..), ExportSpecList(..), Extension(..), KnownExtension(..), Module(..),
  ModuleHead(..), ModuleName(..), Name(..), ParseResult(..), QName(..), parseFileWithExts)
import qualified System.Directory as Dir
import System.Environment (getArgs)
import System.FilePath.Posix (takeDirectory, takeExtension, (</>))

import Util.IO (hSetTranslit, writeFileUtf8)

main :: IO ()
main = do
  hSetTranslit stderr
  args <- getArgs
  case args of
    src : _ : dst : opts -> do
      Config{..} <- parseOpts def (map toText opts)
      contracts <- findContracts cDebug (takeDirectory src)

      verifyContractDecls contracts
      let output = fmt @Text $ unlinesF
            [ "module " +| cModuleName |+ " (contracts) where"
            , ""
            , importsSection contracts
            , ""
            , contractsMapSection contracts
            ]
      printDebug cDebug . fmt $
        "Generated module:\n" +| indentF 2 (build output) |+ ""

      writeFileUtf8 dst output
    _ -> do
      die "Usage: lorentz-discover src _ dst moduleName"

newtype IsDebug = IsDebug Bool

data Config = Config
  { cModuleName :: Text
  , cDebug :: IsDebug
  }

instance Default Config where
  def = Config
    { cModuleName = "Main"
    , cDebug = IsDebug False
    }

parseOpts :: Config -> [Text] -> IO Config
parseOpts cfg = \case
  [] -> pure cfg
  "--debug" : opts ->
    parseOpts cfg{ cDebug = IsDebug True } opts
  "--generated-module" : opts ->
    case opts of
      [] -> die "Usage: `--generated-module <module name>`"
      modName : os -> parseOpts cfg{ cModuleName = modName } os
  opt : _ ->
    die $ "Unknown option: " <> show opt

printDebug :: IsDebug -> Text -> IO ()
printDebug (IsDebug isDebug)
  | isDebug = hPutStrLn stderr . ("contract-discover: " <>)
  | otherwise = \_ -> pass

data ContractInfo = ContractInfo
  { ciModuleName :: Text
  , ciContractDecl :: ContractDecl
  }

data ContractDecl = ContractDecl
  { cdName :: Text
    -- ^ Identifier of a contract, e.g. "auction".
  , cdVar :: Text
    -- ^ Name of a contract as is appears in Haskell code.
  }

findContracts :: IsDebug -> FilePath -> IO [ContractInfo]
findContracts isDebug path = do
  isDir <- Dir.doesDirectoryExist path
  if isDir
    then do
      dirs <- Dir.listDirectory path
      concatMapM (findContracts isDebug) (map (path </>) dirs)
    else do
      if takeExtension path /= ".hs"
        then return []
        else do
          printDebug isDebug $ "Reading module " <> show path
          parseHaskellModule path

parseHaskellModule :: FilePath -> IO [ContractInfo]
parseHaskellModule path = do
  parseRes <- parseFileWithExts hsExtensions path
  case parseRes of
    ParseFailed loc msg ->
      die $ "Parse of module " <> show path <> " failed at " <>
            show loc <> ": " <> msg
    ParseOk (Module _ mModuleHead _ _ _) -> do
      case mModuleHead of
        Just (ModuleHead _ (ModuleName _ moduleName)
                         _ (Just (ExportSpecList _ exports))) ->
          return $
            [ ContractInfo
              { ciModuleName = toText moduleName
              , ciContractDecl = decl
              }
            | export <- exports
            , Just decl <- pure $ toContractDecl export
            ]
        -- Some autogenerated modules may have no export list, so we ignore them
        Just (ModuleHead _ _ _ Nothing) ->
          return []
        Nothing ->
          return []
    ParseOk XmlPage{} ->
      return []
    ParseOk XmlHybrid{} ->
      return []

toContractDecl :: ExportSpec l -> Maybe ContractDecl
toContractDecl = \case
  EVar _ qname -> do
    extName <- case qname of
      Qual _ _ name -> Just name
      UnQual _ name -> Just name
      Special{} -> Nothing
    plainName <- case extName of
      Ident _ name -> Just $ toText name
      Symbol _ _ -> Nothing  -- not interested in operators
    contractDeclFromName plainName
  EAbs{} -> Nothing
  EThingWith{} -> Nothing
  EModuleContents{} -> Nothing

contractDeclFromName :: Text -> Maybe ContractDecl
contractDeclFromName varName = do
  rawName <- T.stripPrefix "contract_" varName
  let name = T.replace "_" " " rawName
  return ContractDecl
    { cdName = name
    , cdVar = varName
    }

-- | Ensures that:
--
-- 1. No two contracts have the same name.
verifyContractDecls :: [ContractInfo] -> IO ()
verifyContractDecls contracts = do
  let vars = map (cdVar . ciContractDecl) contracts
  let dups = map head . mapMaybe (nonEmpty . Unsafe.init) . group $ sort vars
  case dups of
    [] -> pass
    dup : _ -> die $ "Found multiple contracts with the same name: " <> show dup

importsSection :: [ContractInfo] -> Builder
importsSection =
  mconcat . map (<> "\n") .
  (extraImports ++) . map mkImport . ordNub . map ciModuleName
  where
  mkImport m = "import qualified " +| m |+ ""
  extraImports =
    [ "import Data.Text (Text)"
    , "import Data.String (fromString)"
    , "import qualified Data.Map as Map"

    , "import qualified Michelson.Untyped as U"
    , "import Lorentz.Discover"
    ]

contractsMapSection :: [ContractInfo] -> Builder
contractsMapSection contracts =
  "contracts :: Map.Map Text U.Contract\n\
  \contracts = Map.fromList\n  " <> listF' contractPairF contracts
  where
    -- Forms @(contract name, contract variable)@ pair.
    contractPairF ContractInfo{..} =
      let ContractDecl{..} = ciContractDecl
          var = "toUntypedContract " +| ciModuleName |+ "." +| cdVar |+ ""
      in "\n  (\"" +| cdName |+ "\", " +| var +| ")"

-- | Extensions which are enough to parse any module with contract.
hsExtensions :: [Extension]
hsExtensions =
  -- Let's just update this list as the need arises.
  -- It's not necessary to include all extensions which we use, only those
  -- absense of which may cause parse failures, since we read only
  -- module export list.
  --
  -- One of alternative options would be to use 'cabal' package to read
  -- default extensions of the current package and put them here.
  EnableExtension <$>
    [ BangPatterns
    , ConstraintKinds
    , DataKinds
    , DefaultSignatures
    , DeriveAnyClass
    , DerivingStrategies
    , EmptyCase
    , GADTs
    , GeneralizedNewtypeDeriving
    , LambdaCase
    , MultiParamTypeClasses
    , MultiWayIf
    , OverloadedLabels
    , PatternSynonyms
    , ScopedTypeVariables
    , RecordWildCards
    , RecursiveDo
    , TemplateHaskell
    , TupleSections
    , TypeApplications
    , TypeFamilies
    , TypeOperators
    , ViewPatterns
    ]

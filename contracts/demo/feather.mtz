let {
  type Parameter = (Unit, Option Nat);
  type Storage = (Address %counter, Option %caller Address);

  toCounter :: '[Parameter, Storage]
            -> '[(List Operation, Storage)]
  = { car; dip {self}; pair;
      right Nat;
      right Unit;
      dip {dup; car; contract (Unit | Nat | View Unit Nat);
           assert_some; amount
          };
      transfer_tokens;
      nil operation; swap; cons;
      dip {car; sender; some; swap; pair}; pair
    };

  toCaller :: '[Nat, Parameter, Storage]
           -> '[(List Operation, Storage)]
  = { left Unit;
      dip {drop; dup; cdr; assert_some;
           contract (Nat | Unit); assert_some; amount;
          };
      transfer_tokens;
      nil operation; swap; cons;
      dip {car; none address; swap; pair}; pair
    };


};
parameter Parameter;
storage Storage;
code { unpair; dup; cdr; if_some {toCaller} {toCounter};}
